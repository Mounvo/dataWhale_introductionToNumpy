# 索引、切片与迭代

[toc]

## 副本与视图

在Numpy中，尤其是在做数组运算或数组操作时，返回结果不是数组的 **副本** 是 **视图**。

**副本**：是一个数据的完整的拷贝，如果我们对副本进行修改，不会影响到原始数据。

+ 所有赋值运算不会为数组和数组中的任何元素创建副本
+ numpy.ndarray.copy() 函数创建的副本，对副本数据进行修改，并不会影响到原始数据。

**视图**：是数据的一个引用或别称，通过视图可访问、操作原有数据，但原用数据不会产生拷贝，如果我们对视图进行修改，会影响到原始数据。

```python
import numpy as np

x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = x
y[0] = -1
print(x)
# [-1  2  3  4  5  6  7  8]
print(y)
# [-1  2  3  4  5  6  7  8]

x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = x.copy()
y[0] = -1
print(x)
# [1 2 3 4 5 6 7 8]
print(y)
# [-1  2  3  4  5  6  7  8]
```

## 索引与切片

数组索引机制指的是用方括号 ([ ]) 加序号的形式引用单个数组元素

### 整数索引

要获取数组的单个元素，指定元素的索引即可。

#### 一维数组

``` python
arr = np.arange(10)

print(arr)    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

print(arr[5]) # 5
```

#### 二维数组

 访问二维数组时，可以使用逗号分割的整数表示元素的维数和索引，如果忽略了后面的索引，则返回的是一维数组

```python
arr2d = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20],
              [21, 22, 23, 24, 25],
              [26, 27, 28, 29, 30],
              [31, 32, 33, 34, 35]])
print(arr2d[2])  # [21 22 23 24 25]
print(arr2d[2][1])  # 22
print(arr2d[2, 1])  # 22
```

#### 更高维

``` python
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

print(arr3d[0])     #[[1 2 3]  [4 5 6]]
print(arr3d[1][0])  #[7 8 9]

```



### 切片索引

对 numpy 数据进行切片操作得到的数组是指向相同缓冲区的视图，切片语法为( start:stop:step )

#### 一维数组

``` python
x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
print(x[0:2])  # [1 2]
#用下标0~5,以2为步长选取数组
print(x[1:5:2])  # [2 4]
print(x[2:])  # [3 4 5 6 7 8]
print(x[:2])  # [1 2]
print(x[-2:])  # [7 8]
print(x[:-2])  # [1 2 3 4 5 6]
print(x[:])  # [1 2 3 4 5 6 7 8]
#利用负数下标翻转数组
print(x[::-1])  # [8 7 6 5 4 3 2 1]
```

#### 二维数组

对二维数组的切片方式比较不同，我们继续对之前的arr2d进行切片操作

``` python
print(arr2d[:2])
#  [[11 12 13 14 15]
#  [16 17 18 19 20]]

print(arr2d[:2,1:])
#  [[12 13 14 15]
#  [17 18 19 20]]

print(arr2d[2,:])
# [21 22 23 24 25]
```

可以看出，它是沿着0轴的方向进行切片，arr2d[:2]可以理解为“选取前两行”    

也可以一次传入多个切片，以每个逗号为分隔，对每个维度执行单独的切片

### dots索引

Numpy 允许使用...表示足够多的冒号来构建完整的索引列表    

比如，如果 x 是5维数组：

- `x[1,2,...]` 等于 `x[1,2,:,:,:]`
- `x[...,3]` 等于 `x[:,:,:,:,3]`
- `x[4,...,5,:]` 等于 `x[4,:,:,5,:]`

``` python
arr5d = np.random.randint(1, 100, [2, 2, 3])
print(arr5d)
# [[[ 5 64 75]
#   [57 27 31]]
# 
#  [[68 85  3]
#   [93 26 25]]]

print(arr5d[1, ...])
# [[68 85  3]
#  [93 26 25]]

print(arr5d[..., 2])
# [[75 31]
#  [ 3 25]]

print(arr5d[1,...,1:])
# [[20 52]
# [96 12]]
```

### 整数数组索引

可以传入多个索引值，同时选择多个元素

``` python
x = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20],
              [21, 22, 23, 24, 25],
              [26, 27, 28, 29, 30],
              [31, 32, 33, 34, 35]])

r = [0, 1, 2]
print(x[r])
# [[11 12 13 14 15]
#  [16 17 18 19 20]
#  [21 22 23 24 25]]

r = [0, 1, 2]
c = [2, 3, 4]
y = x[r, c]
print(y)
# [13 19 25]
```

``` python
x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
r = np.array([[0, 1], [3, 4]])
print(x[r])
# [[1 2]
#  [4 5]]
# 重构二维数组
x = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20],
              [21, 22, 23, 24, 25],
              [26, 27, 28, 29, 30],
              [31, 32, 33, 34, 35]])

r = np.array([[0, 1], [3, 4]])
print(x[r])
# [[[11 12 13 14 15]
#   [16 17 18 19 20]]
#
#  [[26 27 28 29 30]
#   [31 32 33 34 35]]]
```

也可以获取四个角的元素

``` python
r = np.array([[0, 0], [4, 4]])
c = np.array([[0, 4], [0, 4]])
y = x[r, c]
print(y)
# [[11 15]
#  [31 35]]
```

也可以借助切片：与整数数组组合

``` python
x = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20],
              [21, 22, 23, 24, 25],
              [26, 27, 28, 29, 30],
              [31, 32, 33, 34, 35]])

y = x[0:3, [1, 2, 2]]
print(y)
# [[12 13 13]
#  [17 18 18]
#  [22 23 23]]
```

numpy.take(a, indices, axis=None, out=None, mode='raise') :沿着轴从数组中获取元素

``` python
x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
r = [0, 1, 2]
print(np.take(x, r))
# [1 2 3]

r = [0, 1, -1]
print(np.take(x, r))
# [1 2 8]

x = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20],
              [21, 22, 23, 24, 25],
              [26, 27, 28, 29, 30],
              [31, 32, 33, 34, 35]])

r = [0, 1, 2]
print(np.take(x, r, axis=0))
# [[11 12 13 14 15]
#  [16 17 18 19 20]
#  [21 22 23 24 25]]

r = [0, 1, -1]
print(np.take(x, r, axis=1))
# [[11 12 15]
#  [16 17 20]
#  [21 22 25]
#  [26 27 30]
#  [31 32 35]]

r = [0, 1, 2]
c = [2, 3, 4]
y = np.take(x, [r, c])
print(y)
# [[11 12 13]
#  [13 14 15]]
```

使用切片索引到numpy数组时，生成的数组视图始终是原始数组的子数组，但是整数数组索引不是其子数组，而是形成了新的数组    

``` python
a=np.array([[1,2],[3,4],[5,6]])
#整数数组索引，形成了新的数组
c=a[0,0]
c=2
print(a[0,0]==c)
#False
#切片索引，生成视图
b=a[0:1,0:1]
b[0,0]=2
print(a[0,0]==b)
#[[ True]]
```

### 布尔索引

我们可以通过一个布尔数组来索引目标数组

``` python
x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = x > 5
print(y)
# [False False False False False  True  True  True]
print(x[x > 5])
# [6 7 8]
```

过滤NaN

``` python
import numpy as np 
 
a = np.array([np.nan,  1,2,np.nan,3,4,5])  
print (a[~np.isnan(a)])
# [1. 2. 3. 4. 5.]
```

## 数组迭代

Numpy提供另一种较为优雅的方式来进行遍历：apply_along_axis(funcld, axis, arr)  沿给定的轴的方向对n维切片应用一个函数

``` python
x = np.array([[11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20],
              [21, 22, 23, 24, 25],
              [26, 27, 28, 29, 30],
              [31, 32, 33, 34, 35]])

y = np.apply_along_axis(np.sum, 0, x)
print(y)
# [105 110 115 120 125]
z = np.apply_along_axis(np.sum, 1, x)
print(z)
# [ 65  90 115 140 165]

def my_func(x):
    return (x[0] + x[-1]) * 0.5

i = np.apply_along_axis(my_func, 0, x)
print(i)
# [21. 22. 23. 24. 25.]
```







